!!! Calcula anisotropías para el arreglo de 1500m usando análisis Rayleigh en diferentes frecuencias: sidérea, solar o anti-sidérea.
!!! También tiene la opción de calcular usando método East-West y el método de los armónicos esféricos.
!!! Funciona en simple y doble precisión
!
! 	compile with:	
!  gfortran anisotropy_ma.f90 -L /mnt/Datos/oscar/lapack-3.4.2 -llapack -lrefblas
!  or if asymmetric errors needed with: 
!  gfortran -I obj/ anisotropy_ma.f90 -L /mnt/Datos/oscar/lapack-3.4.2 -llapack -lrefblas obj/dipcl.o
!==============================================================================
!     variables globales a usar en el programa 
MODULE globalvars
  USE globalconsts
  IMPLICIT NONE
  INTEGER,PARAMETER :: pr = sp
  REAL(pr),PARAMETER :: pi = pi_s
  REAL(pr),PARAMETER :: d2r = pi/180.
  REAL(pr),PARAMETER :: rho0 = 1.06,P0 = 862.0,Bb = 1.03
  REAL(pr),PARAMETER :: bw = 1.
  REAL(pr),ALLOCATABLE :: dnhexra(:),dwra(:,:)
  REAL(pr) :: Emin(7)=(/0.125,0.25,0.5,1.,2.,4.,8./)
!  REAL(pr) :: Emin(7)=(/0.,0.,0.,4.,8.,16.,32./)
  REAL(pr) :: Eminb(2)=(/4.,8./)
CONTAINS
END MODULE globalvars
      
PROGRAM anisotropy
  USE globalvars
  INTEGER size,utci,utcf,bine,is5t5,meth,freq
  REAL(pr) :: zmax
  CHARACTER(10) :: itime,ftime
  CHARACTER(80) :: command

  INTERFACE
     SUBROUTINE dipoleSolar(iscor,freq,utci_opt,utcf,zmin_opt,zmax,is5t5_opt,iseff_opt,bine)
       USE globalvars
       INTEGER :: iscor,freq,utcf,bine
       REAL(pr) :: zmax
       INTEGER(pr),OPTIONAL :: utci_opt,is5t5_opt,iseff_opt
       REAL(pr),OPTIONAL :: zmin_opt
     END SUBROUTINE dipoleSolar


     SUBROUTINE dipoleEW(ifrec,utci_opt,utcf,zmin_opt,zmax,is5t5_opt,bine)
       USE globalvars
       USE dipcl
       INTEGER :: iscor,utcf,bine
       REAL(pr) :: zmax
       INTEGER(pr),OPTIONAL :: utci_opt,is5t5_opt
       REAL(pr),OPTIONAL :: zmin_opt
     END SUBROUTINE dipoleEW
  END INTERFACE
  
  open(unit=13,file='tmp.dat')
  open(unit=1,file='HeraldInfill001EeV055noBP.dat')
!  open(unit=2,file='../CIC-Energycal/HeraldCorrectwg050a04_6t5_alltrig_310517.dat')
!  open(unit=2,file='../CIC-Energycal/HeraldCorrectwg060noBP5n6t5_pnop_080916_wca1.dat')
  

!  open(unit=2,file='Herald080noBP5n6t5a4_pnop_04-310816_wca1.dat')
  !	open(unit=2,file='energybins080_6T5a4.dat')
  !	open(unit=3,file='dip060Coreff1_04-14_wca1.tmp')
  
  !     open(unit=3,file='dip60805T5_04-311214.dat')

  !open(unit=8,file='dnhexra6T5_010713-310517.dat')
  
  !open(unit=9,file='rayleighcoefs.dat')

  open(unit=16,file='expsolmaindN_04-14_wca1.dat')
  open(unit=17,file='expsidmaindN_04-14_wca1v2.dat')
  open(unit=13,file='ev0805n6T5a4_pnop_04-310816_wca1.dat')


  ! dates mm/dd/yy
  itime = '1/1/2004'
  ftime = '1/1/2018'
  command = "date -u +%s --date='"//trim(itime)//"' > tmpdummy.xx"
  call system(command)
  command = "date -u +%s --date='"//trim(ftime)//"' >> tmpdummy.xx"
  call system(command)
  open(unit=9,action='READ',file='tmpdummy.xx')
  read(9,*)utci
  read(9,*)utcf
  close(unit=9)
  call system("rm tmpdummy.xx")

  bine = 2
  zmin = 0.
  zmax = 80.
  is5t5 = 1
  iseff = 1
  meth = 1
  freq = 1 ! 0 Solar, 1 Antisid

  if(bine.eq.6.or.bine.eq.4) then
     open(unit=2,file='Herald080noBP5n6t5a4_pnop_04-310816_wca1.dat')
!     open(unit=2,file='Herald080noBP5n6t5a4_pnop_04-311217.dat')
!     open(unit=2,file='Herald080noBP5n6t5a4_pnop_04-311217_Eraw.dat')
!     open(unit=2,file='Herald080noBP5n6t5a4_pnop_04-311217_NKG.dat')
     iseff = 0
  else
     open(unit=2,file='Herald060noBP6T5_04-311217.dat')
!     open(unit=2,file='Herald060noBP6T5_04-311217_NKG.dat')
!     open(unit=2,file='Herald060noBP6T5_04-310517.dat')
     is5t5 = 0
     zmax = 60.
  endif

  select case (meth)
  case (1)
     call dipoleSolar(iscor=1,freq=freq,utci_opt=utci,utcf=utcf,zmax=zmax,is5t5_opt=is5t5,bine=bine,iseff_opt=iseff) ! if arg1 = 0 raw energy | corrected energy otherwise
  case (2)
     call dipoleRA(iscor=1,utci_opt=utci,utcf=utcf,zmin_opt=zmin,zmax=zmax,is5t5_opt=is5t5,iseff_opt=iseff,bine=bine,outfmt=2)  ! if arg = 0 raw energy | corrected energy otherwise
  case (3)
     call dipolepquadRA(utcf=utcf,zmin_opt=zmin,zmax=zmax,is5t5_opt=is5t5,bine=bine,outfmt=1)
  case (4)
     call dipoleEW(ifrec=0,utci_opt=utci,utcf=utcf,zmax=zmax,is5t5_opt=is5t5,bine=bine)  ! if arg = 0 sidereal freq | solar freq otherwise
  end select

END PROGRAM anisotropy

!===========================================================================
!------------------------------------------------------------------------------
! calculates the dipole components using East-West method
  SUBROUTINE dipoleEW(ifrec,utci_opt,utcf,zmin_opt,zmax,is5t5_opt,bine)
    USE globalvars
    USE dipcl
    INTEGER :: iscor,utcf,bine
    REAL(pr) :: zmax
    INTEGER(pr),OPTIONAL :: utci_opt,is5t5_opt
    REAL(pr),OPTIONAL :: zmin_opt
    REAL(pr) :: aew,bew,avg(10),promsint,promcosd
    REAL(pr) :: rad,rtilde,dper,dz,decd,rd,atan02pi,zmin
    REAL*8 :: rp,rm
    INTEGER :: ifrec,utci,is5t5
    open(unit=10,file='dip080EW5n6T5_pnop_04-0517.dat')

    ! //// optional arguments
    utci = 0
    zmin = 0._pr
    is5t5 = 0
    if(present(utci_opt))utci = utci_opt
    if(present(zmin_opt))zmin = zmin_opt
    if(present(is5t5_opt))is5t5 = is5t5_opt

    
    nbin = 7
    
    do i=bine,nbin
       ! Estimate dipole amplitude and phase using East-West method
       call East_West(i,aew,bew,promsint,promcosd,nval,ifrec,utci,utcf,zmin,zmax,is5t5,bine)
       rtilde = sqrt(aew**2 + bew**2)
       rad = atan02pi(aew,bew) + 0.5*pi
       if(rad.gt.2.*pi) rad = rad - 2.*pi
       dper = 0.5*pi*rtilde/promsint
       prtilde=exp(-rtilde**2*nval/4.)
       
       !////////////// error estimates
       sigray = sqrt(2./nval)
       if(sigray.le.rtilde) sgmrad2=asin(sigray/rtilde)
       if(sigray.gt.rtilde) sgmrad2=pi
       sgmrad = sigray/rtilde
       sgmdper = sigray*0.5*pi/promsint
       rray = rtilde*pi*promcosd/(2*promsint)
       sigma = sigray*pi*promcosd/(2*promsint)
       r99 = sqrt(4.*log(100.)/nval)*pi*promcosd/(2*promsint)

       write(6,*)E,rray,sigma,rad/d2r,sgmrad/d2r,r99,nval,prtilde,dper,real(rp/promcosd),real(rm/promcosd)
    enddo
    return
  END SUBROUTINE dipoleEW
!=============================================================================
!---------------------------------------------------------------------
!=======================================================================
!----------------------------------------------------------------
!	Computes the  coefficients	from the East-West method
!     ifrec = 0 -----> use sidereal frequency
!     ifrec != 0 -----> use solar frequency
  SUBROUTINE East_West(bin,aew,bew,avgst,avgcd,nval,ifrec,utci,utcf,zmin,zmax,is5t5,bine)
    USE globalvars
    INTEGER :: utci,utcf,is5t5,bine
    REAL(pr) :: zmin,zmax
    INTEGER :: bin,binid,nval,UTC,t5,ifrec,utc0
    REAL(pr) :: Dec,Ra,Ra0,energy,DeltaNHexaAtRa,Theta,Phi,c,d
    REAL(pr) :: aew,bew,avgst,avgcd
    
    iutcref = 1104537600   !1/1/2005
    utc0 = 1072915200
    nval=0
    ne=0
    nw=0
    aew = 0.
    bew = 0.
    avgst = 0.
    avgcd = 0.
    rewind(unit=2)
    read (2,*)

40  if(bine.eq.6.or.bine.eq.4) then         
       read (2,*,end=41)AugId,Dec,Ra,Ecor,UTC,Theta,Phi,t5,ftr
    else
       read (2,*,end=41)AugId,UTC,Phi,Theta,Dec,Ra,Ecor,p,r,rav,iw
    endif
    
    if(UTC.lt.utci.or.UTC.gt.utcf)goto 40 
    if(Theta.lt.zmin.or.Theta.gt.zmax)goto 40 
    if(is5t5.eq.0.and.t5.eq.5)goto 40 

    !energy=Eraw
    energy=Ecor
    binid=0
  
    
    if (binid.eq.bin) then    ! only includes data on the current bin
       nval = nval + 1
       raz=float(UTC-iutcref)/239.345+31.4971
       raz=mod(raz,360.)
       if(raz.lt.0.0)raz=raz+360.
       hrs=float(UTC-utc0)/3600.0
       arg=(hrs+21.)/24.0*2.0*pi
       
       !c  using phi to define E,W
       ieast=0void
       
       !c			if(Phi.lt.90..or.Phi.gt.270.) ieast=1
       
        if(abs(Phi).lt.90.) ieast=1
       if(ieast.gt.0) then
          ne=ne+1
          if(ifrec.eq.0) then
             aew=aew + cos(raz*d2r)
             bew=bew + sin(raz*d2r)
          else
             aew=aew + cos(arg)
             bew=bew + sin(arg)
          endif
       else
          nw=nw+1
          if(ifrec.eq.0) then
             aew=aew + cos(raz*d2r+pi)
             bew=bew + sin(raz*d2r+pi)
          else
             aew=aew + cos(arg+pi)
             bew=bew + sin(arg+pi)
          endif
       endif
       !--sum sin(Theta)
       avgst = avgst + sin(Theta*d2r)
       !--sum cos(Dec)
       avgcd = avgcd + cos(Dec*d2r)
    end if
    goto 40
41  continue
    aew = 2.*aew/nval
    bew = 2.*bew/nval
    avgst = avgst/nval
    avgcd = avgcd/nval
    !c		write(6,*)ne,nw
    return
  END SUBROUTINE East_West
!-------------------------------------------------------------
!-----------------------------------------------------------
